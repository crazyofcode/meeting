# 从状态机理解计算机系统

* 程序
* 指令集
* CPU

## 关于状态机的简单定义

* 状态集合S={S1,S2,....}
* 激励事件E
* 状态转移规则next:S x E -> S
  * 描述每个状态在不同的激励事件下的状态

* 初始化状态S0(属于集合S)

## 计算机系统的状态机模型

### 一个简单的计算机系统

> 程序直接运行在CPU上

![简单计算机的层次结构](https://github.com/crazyofcode/meeting/blob/main/6.png)

然后分别三个抽象层次来用状态机理解

### 程序

'以C程序为例'

* C程序的组成

> * 变量 - 计算的对象
> * 语句 - 计算的操作流程
> * 输入输出函数 - 变量与外界交互的工具

~~~c
int main(int argc, char** argv)
{
  int x = 1;
  int y = 2;
  int z = x + y;
  printf("%d\n", z);
  return 0;
}
~~~

#### 状态机模型

* 状态集合S= { < V, PC> }

  > * V = {v1, v2 ,v3, ......}  => 程序中所有变量的取值
  >
  >   > * 变量包括全局变量和局部变量
  >
  > * PC = 程序计数器 = 当前被执行语句的位置

* 激励事件E = {语句}

  > PC当前指向的语句

* 状态转移规则next: S x E -> S

  > * 语句的语义

* 初始状态S0 = <V0, main函数的第一条语句>

![一个简单的模型](https://github.com/crazyofcode/meeting/blob/main/5.png)

> 关于语句的定义： 请STFM

----------------------------------------------------------

#### 插入一点关于c程序执行的内容

程序的入口函数真的main函数吗

~~~bash
// 可以通过strace工具来追踪，从而理解程序的动态行为
$ strace ./main 
~~~

![示例](https://github.com/crazyofcode/meeting/blob/main/4.png)

可以看到最开始执行的是execve函数去加载一个新程序的代码段的数据段，然后切换到指定的任务开始执行

~~~txt
5.1.2 Execution environments
Two execution environments are defined: freestanding and hosted. In both cases,
program startup occurs when a designated C function is called by the execution
environment...
有一个概念叫执行环境, 原来是它来调用一个专门的C函数

执行环境有两种: 独立环境(freestanding)和宿主环境(hosted)
 

5.1.2.1 Freestanding environment
1. In a freestanding environment (in which C program execution may take place
without any benefit of an operating system), the name and type of the function
called at program startup are implementation-defined.
在独立环境下, 这个专门的C函数由具体实现来决定

5.1.2.2 Hosted environments
5.1.2.2.1 Program startup
1. The function called at program startup is named main...
在宿主环境下, 这个专门的C函数名称为main
~~~

-----

### CPU

* 数字逻辑电路 = 组合逻辑电路 + 时序逻辑电路

* 状态集合S = {<时序逻辑元件的值>}

  > * 具体包括寄存器，存储器，触发器

* 激励事件E= {组合逻辑}

* 状态转移规则next： S x E -> S

  > 由逻辑电路决定

* 初始状态S0 = <复位时时序逻辑元件的值>

eg:

![Johnson计数器](https://github.com/crazyofcode/meeting/blob/main/3.png)

### 指令集

一个抽象的定义: 是软件与硬件之间的接口。     (不过好像没有什么意义)

想了解指令集是什么，最好的方法就是用过手册等去了解

![关于指令集架构的小知识](https://github.com/crazyofcode/meeting/blob/main/2.png)

指令集定义的状态机

* 状态集合S = {<R, M>}

  > * R = {PC, x0, x1, x2, x3, ....}
  >
  >   > RISC-V手册 -> Programmers' Model for Base Integer ISA
  >   >
  >   > PC = 程序计数器
  >
  >   * M = 内存
  >
  >     > RISC-V手册 -> 1.4 Memory

* 激励事件E = {指令}

  > 执行PC指向的指令

* 状态转移规则next: S x E -> S

  > 指令的语义

* 初始状态S0 = <R0, M0>

![用C程序理解指令](https://github.com/crazyofcode/meeting/blob/main/1.png)

指令的两种表示方法：

1. 符号化表示 -> 面向程序员
2. 编码表示 -> 面向电路设计